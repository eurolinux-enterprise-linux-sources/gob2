/* Generated by generate_treefuncs.pl from treefuncs.def!
 * Do not edit by hand! */

#include <glib.h>
#include <stdarg.h>
#include "treefuncs.h"

#define COPY_LIST_VALS(list,func) { GList *li; for (li=(list);li;li=li->next) { li->data=func (li->data); } }

static Argument *
copy_argument (Argument * self);
static CCode *
copy_ccode (CCode * self);
static Check *
copy_check (Check * self);
static Class *
copy_class (Class * self);
static EnumDef *
copy_enumdef (EnumDef * self);
static EnumValue *
copy_enumvalue (EnumValue * self);
static Error *
copy_error (Error * self);
static Flags *
copy_flags (Flags * self);
static FuncArg *
copy_funcarg (FuncArg * self);
static Method *
copy_method (Method * self);
static Property *
copy_property (Property * self);
static Type *
copy_type (Type * self);
static Variable *
copy_variable (Variable * self);

void
free_argument (Argument * self);
void
free_ccode (CCode * self);
void
free_check (Check * self);
void
free_class (Class * self);
void
free_enumdef (EnumDef * self);
void
free_enumvalue (EnumValue * self);
void
free_error (Error * self);
void
free_flags (Flags * self);
void
free_funcarg (FuncArg * self);
void
free_method (Method * self);
void
free_property (Property * self);
void
free_type (Type * self);
void
free_variable (Variable * self);

static void
setv_argument (Argument * self, va_list __ap);
static void
setv_ccode (CCode * self, va_list __ap);
static void
setv_check (Check * self, va_list __ap);
static void
setv_class (Class * self, va_list __ap);
static void
setv_enumdef (EnumDef * self, va_list __ap);
static void
setv_enumvalue (EnumValue * self, va_list __ap);
static void
setv_error (Error * self, va_list __ap);
static void
setv_flags (Flags * self, va_list __ap);
static void
setv_funcarg (FuncArg * self, va_list __ap);
static void
setv_method (Method * self, va_list __ap);
static void
setv_property (Property * self, va_list __ap);
static void
setv_type (Type * self, va_list __ap);
static void
setv_variable (Variable * self, va_list __ap);

static gboolean quarks_set_up = FALSE;
static GHashTable *quark_ht;
enum {
	QUARK_0,
	QUARK_otype,
	QUARK_otype_STEAL,
	QUARK_ptype,
	QUARK_ptype_STEAL,
	QUARK_bonobo_object_class,
	QUARK_bonobo_object_class_STEAL,
	QUARK_glade_xml,
	QUARK_chunk_size,
	QUARK_chunk_size_STEAL,
	QUARK_interfaces,
	QUARK_interfaces_STEAL,
	QUARK_nodes,
	QUARK_nodes_STEAL,
	QUARK_abstract,
	QUARK_name,
	QUARK_name_STEAL,
	QUARK_pointer,
	QUARK_pointer_STEAL,
	QUARK_postfix,
	QUARK_postfix_STEAL,
	QUARK_cctype,
	QUARK_cbuf,
	QUARK_cbuf_STEAL,
	QUARK_line_no,
	QUARK_chtype,
	QUARK_number,
	QUARK_number_STEAL,
	QUARK_atype,
	QUARK_atype_STEAL,
	QUARK_checks,
	QUARK_checks_STEAL,
	QUARK_gtktype,
	QUARK_gtktype_STEAL,
	QUARK_flags,
	QUARK_flags_STEAL,
	QUARK_get,
	QUARK_get_STEAL,
	QUARK_get_line,
	QUARK_set,
	QUARK_set_STEAL,
	QUARK_set_line,
	QUARK_nick,
	QUARK_nick_STEAL,
	QUARK_blurb,
	QUARK_blurb_STEAL,
	QUARK_minimum,
	QUARK_minimum_STEAL,
	QUARK_maximum,
	QUARK_maximum_STEAL,
	QUARK_default_value,
	QUARK_default_value_STEAL,
	QUARK_extra_gtktype,
	QUARK_extra_gtktype_STEAL,
	QUARK_override,
	QUARK_link,
	QUARK_export,
	QUARK_scope,
	QUARK_method,
	QUARK_mtype,
	QUARK_mtype_STEAL,
	QUARK_gtktypes,
	QUARK_gtktypes_STEAL,
	QUARK_id,
	QUARK_id_STEAL,
	QUARK_args,
	QUARK_args_STEAL,
	QUARK_funcattrs,
	QUARK_funcattrs_STEAL,
	QUARK_onerror,
	QUARK_onerror_STEAL,
	QUARK_defreturn,
	QUARK_defreturn_STEAL,
	QUARK_ccode_line,
	QUARK_vararg,
	QUARK_unique_id,
	QUARK_bonobo_object_func,
	QUARK_interface,
	QUARK_interface_STEAL,
	QUARK_vtype,
	QUARK_vtype_STEAL,
	QUARK_glade_widget,
	QUARK_destructor_unref,
	QUARK_destructor,
	QUARK_destructor_STEAL,
	QUARK_destructor_line,
	QUARK_destructor_simple,
	QUARK_initializer,
	QUARK_initializer_STEAL,
	QUARK_initializer_line,
	QUARK_initializer_simple,
	QUARK_etype,
	QUARK_etype_STEAL,
	QUARK_prefix,
	QUARK_prefix_STEAL,
	QUARK_values,
	QUARK_values_STEAL,
	QUARK_value,
	QUARK_value_STEAL,
	QUARK_ftype,
	QUARK_ftype_STEAL,
	QUARK_LAST
};

static void
ensure_quarks (void)
{
	if (quarks_set_up)
		return;
	quark_ht = g_hash_table_new (g_str_hash, g_str_equal);
	quarks_set_up = TRUE;
	g_hash_table_insert (quark_ht, "otype", GINT_TO_POINTER (QUARK_otype));
	g_hash_table_insert (quark_ht, "otype:steal", GINT_TO_POINTER (QUARK_otype_STEAL));
	g_hash_table_insert (quark_ht, "ptype", GINT_TO_POINTER (QUARK_ptype));
	g_hash_table_insert (quark_ht, "ptype:steal", GINT_TO_POINTER (QUARK_ptype_STEAL));
	g_hash_table_insert (quark_ht, "bonobo_object_class", GINT_TO_POINTER (QUARK_bonobo_object_class));
	g_hash_table_insert (quark_ht, "bonobo_object_class:steal", GINT_TO_POINTER (QUARK_bonobo_object_class_STEAL));
	g_hash_table_insert (quark_ht, "glade_xml", GINT_TO_POINTER (QUARK_glade_xml));
	g_hash_table_insert (quark_ht, "chunk_size", GINT_TO_POINTER (QUARK_chunk_size));
	g_hash_table_insert (quark_ht, "chunk_size:steal", GINT_TO_POINTER (QUARK_chunk_size_STEAL));
	g_hash_table_insert (quark_ht, "interfaces", GINT_TO_POINTER (QUARK_interfaces));
	g_hash_table_insert (quark_ht, "interfaces:steal", GINT_TO_POINTER (QUARK_interfaces_STEAL));
	g_hash_table_insert (quark_ht, "nodes", GINT_TO_POINTER (QUARK_nodes));
	g_hash_table_insert (quark_ht, "nodes:steal", GINT_TO_POINTER (QUARK_nodes_STEAL));
	g_hash_table_insert (quark_ht, "abstract", GINT_TO_POINTER (QUARK_abstract));
	g_hash_table_insert (quark_ht, "name", GINT_TO_POINTER (QUARK_name));
	g_hash_table_insert (quark_ht, "name:steal", GINT_TO_POINTER (QUARK_name_STEAL));
	g_hash_table_insert (quark_ht, "pointer", GINT_TO_POINTER (QUARK_pointer));
	g_hash_table_insert (quark_ht, "pointer:steal", GINT_TO_POINTER (QUARK_pointer_STEAL));
	g_hash_table_insert (quark_ht, "postfix", GINT_TO_POINTER (QUARK_postfix));
	g_hash_table_insert (quark_ht, "postfix:steal", GINT_TO_POINTER (QUARK_postfix_STEAL));
	g_hash_table_insert (quark_ht, "cctype", GINT_TO_POINTER (QUARK_cctype));
	g_hash_table_insert (quark_ht, "cbuf", GINT_TO_POINTER (QUARK_cbuf));
	g_hash_table_insert (quark_ht, "cbuf:steal", GINT_TO_POINTER (QUARK_cbuf_STEAL));
	g_hash_table_insert (quark_ht, "line_no", GINT_TO_POINTER (QUARK_line_no));
	g_hash_table_insert (quark_ht, "chtype", GINT_TO_POINTER (QUARK_chtype));
	g_hash_table_insert (quark_ht, "number", GINT_TO_POINTER (QUARK_number));
	g_hash_table_insert (quark_ht, "number:steal", GINT_TO_POINTER (QUARK_number_STEAL));
	g_hash_table_insert (quark_ht, "atype", GINT_TO_POINTER (QUARK_atype));
	g_hash_table_insert (quark_ht, "atype:steal", GINT_TO_POINTER (QUARK_atype_STEAL));
	g_hash_table_insert (quark_ht, "checks", GINT_TO_POINTER (QUARK_checks));
	g_hash_table_insert (quark_ht, "checks:steal", GINT_TO_POINTER (QUARK_checks_STEAL));
	g_hash_table_insert (quark_ht, "gtktype", GINT_TO_POINTER (QUARK_gtktype));
	g_hash_table_insert (quark_ht, "gtktype:steal", GINT_TO_POINTER (QUARK_gtktype_STEAL));
	g_hash_table_insert (quark_ht, "flags", GINT_TO_POINTER (QUARK_flags));
	g_hash_table_insert (quark_ht, "flags:steal", GINT_TO_POINTER (QUARK_flags_STEAL));
	g_hash_table_insert (quark_ht, "get", GINT_TO_POINTER (QUARK_get));
	g_hash_table_insert (quark_ht, "get:steal", GINT_TO_POINTER (QUARK_get_STEAL));
	g_hash_table_insert (quark_ht, "get_line", GINT_TO_POINTER (QUARK_get_line));
	g_hash_table_insert (quark_ht, "set", GINT_TO_POINTER (QUARK_set));
	g_hash_table_insert (quark_ht, "set:steal", GINT_TO_POINTER (QUARK_set_STEAL));
	g_hash_table_insert (quark_ht, "set_line", GINT_TO_POINTER (QUARK_set_line));
	g_hash_table_insert (quark_ht, "nick", GINT_TO_POINTER (QUARK_nick));
	g_hash_table_insert (quark_ht, "nick:steal", GINT_TO_POINTER (QUARK_nick_STEAL));
	g_hash_table_insert (quark_ht, "blurb", GINT_TO_POINTER (QUARK_blurb));
	g_hash_table_insert (quark_ht, "blurb:steal", GINT_TO_POINTER (QUARK_blurb_STEAL));
	g_hash_table_insert (quark_ht, "minimum", GINT_TO_POINTER (QUARK_minimum));
	g_hash_table_insert (quark_ht, "minimum:steal", GINT_TO_POINTER (QUARK_minimum_STEAL));
	g_hash_table_insert (quark_ht, "maximum", GINT_TO_POINTER (QUARK_maximum));
	g_hash_table_insert (quark_ht, "maximum:steal", GINT_TO_POINTER (QUARK_maximum_STEAL));
	g_hash_table_insert (quark_ht, "default_value", GINT_TO_POINTER (QUARK_default_value));
	g_hash_table_insert (quark_ht, "default_value:steal", GINT_TO_POINTER (QUARK_default_value_STEAL));
	g_hash_table_insert (quark_ht, "extra_gtktype", GINT_TO_POINTER (QUARK_extra_gtktype));
	g_hash_table_insert (quark_ht, "extra_gtktype:steal", GINT_TO_POINTER (QUARK_extra_gtktype_STEAL));
	g_hash_table_insert (quark_ht, "override", GINT_TO_POINTER (QUARK_override));
	g_hash_table_insert (quark_ht, "link", GINT_TO_POINTER (QUARK_link));
	g_hash_table_insert (quark_ht, "export", GINT_TO_POINTER (QUARK_export));
	g_hash_table_insert (quark_ht, "scope", GINT_TO_POINTER (QUARK_scope));
	g_hash_table_insert (quark_ht, "method", GINT_TO_POINTER (QUARK_method));
	g_hash_table_insert (quark_ht, "mtype", GINT_TO_POINTER (QUARK_mtype));
	g_hash_table_insert (quark_ht, "mtype:steal", GINT_TO_POINTER (QUARK_mtype_STEAL));
	g_hash_table_insert (quark_ht, "gtktypes", GINT_TO_POINTER (QUARK_gtktypes));
	g_hash_table_insert (quark_ht, "gtktypes:steal", GINT_TO_POINTER (QUARK_gtktypes_STEAL));
	g_hash_table_insert (quark_ht, "id", GINT_TO_POINTER (QUARK_id));
	g_hash_table_insert (quark_ht, "id:steal", GINT_TO_POINTER (QUARK_id_STEAL));
	g_hash_table_insert (quark_ht, "args", GINT_TO_POINTER (QUARK_args));
	g_hash_table_insert (quark_ht, "args:steal", GINT_TO_POINTER (QUARK_args_STEAL));
	g_hash_table_insert (quark_ht, "funcattrs", GINT_TO_POINTER (QUARK_funcattrs));
	g_hash_table_insert (quark_ht, "funcattrs:steal", GINT_TO_POINTER (QUARK_funcattrs_STEAL));
	g_hash_table_insert (quark_ht, "onerror", GINT_TO_POINTER (QUARK_onerror));
	g_hash_table_insert (quark_ht, "onerror:steal", GINT_TO_POINTER (QUARK_onerror_STEAL));
	g_hash_table_insert (quark_ht, "defreturn", GINT_TO_POINTER (QUARK_defreturn));
	g_hash_table_insert (quark_ht, "defreturn:steal", GINT_TO_POINTER (QUARK_defreturn_STEAL));
	g_hash_table_insert (quark_ht, "ccode_line", GINT_TO_POINTER (QUARK_ccode_line));
	g_hash_table_insert (quark_ht, "vararg", GINT_TO_POINTER (QUARK_vararg));
	g_hash_table_insert (quark_ht, "unique_id", GINT_TO_POINTER (QUARK_unique_id));
	g_hash_table_insert (quark_ht, "bonobo_object_func", GINT_TO_POINTER (QUARK_bonobo_object_func));
	g_hash_table_insert (quark_ht, "interface", GINT_TO_POINTER (QUARK_interface));
	g_hash_table_insert (quark_ht, "interface:steal", GINT_TO_POINTER (QUARK_interface_STEAL));
	g_hash_table_insert (quark_ht, "vtype", GINT_TO_POINTER (QUARK_vtype));
	g_hash_table_insert (quark_ht, "vtype:steal", GINT_TO_POINTER (QUARK_vtype_STEAL));
	g_hash_table_insert (quark_ht, "glade_widget", GINT_TO_POINTER (QUARK_glade_widget));
	g_hash_table_insert (quark_ht, "destructor_unref", GINT_TO_POINTER (QUARK_destructor_unref));
	g_hash_table_insert (quark_ht, "destructor", GINT_TO_POINTER (QUARK_destructor));
	g_hash_table_insert (quark_ht, "destructor:steal", GINT_TO_POINTER (QUARK_destructor_STEAL));
	g_hash_table_insert (quark_ht, "destructor_line", GINT_TO_POINTER (QUARK_destructor_line));
	g_hash_table_insert (quark_ht, "destructor_simple", GINT_TO_POINTER (QUARK_destructor_simple));
	g_hash_table_insert (quark_ht, "initializer", GINT_TO_POINTER (QUARK_initializer));
	g_hash_table_insert (quark_ht, "initializer:steal", GINT_TO_POINTER (QUARK_initializer_STEAL));
	g_hash_table_insert (quark_ht, "initializer_line", GINT_TO_POINTER (QUARK_initializer_line));
	g_hash_table_insert (quark_ht, "initializer_simple", GINT_TO_POINTER (QUARK_initializer_simple));
	g_hash_table_insert (quark_ht, "etype", GINT_TO_POINTER (QUARK_etype));
	g_hash_table_insert (quark_ht, "etype:steal", GINT_TO_POINTER (QUARK_etype_STEAL));
	g_hash_table_insert (quark_ht, "prefix", GINT_TO_POINTER (QUARK_prefix));
	g_hash_table_insert (quark_ht, "prefix:steal", GINT_TO_POINTER (QUARK_prefix_STEAL));
	g_hash_table_insert (quark_ht, "values", GINT_TO_POINTER (QUARK_values));
	g_hash_table_insert (quark_ht, "values:steal", GINT_TO_POINTER (QUARK_values_STEAL));
	g_hash_table_insert (quark_ht, "value", GINT_TO_POINTER (QUARK_value));
	g_hash_table_insert (quark_ht, "value:steal", GINT_TO_POINTER (QUARK_value_STEAL));
	g_hash_table_insert (quark_ht, "ftype", GINT_TO_POINTER (QUARK_ftype));
	g_hash_table_insert (quark_ht, "ftype:steal", GINT_TO_POINTER (QUARK_ftype_STEAL));
}

static Argument *
copy_argument (Argument * self)
{
	Argument * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == ARGUMENT_NODE, NULL);
	new = g_new0(Argument, 1);
	new->type = ARGUMENT_NODE;
	new->gtktype = g_strdup (self->gtktype);
	new->atype = copy_type (self->atype);
	new->flags = g_list_copy (self->flags); COPY_LIST_VALS(new->flags, g_strdup);
	new->name = g_strdup (self->name);
	new->get = g_strdup (self->get);
	new->get_line = self->get_line;
	new->set = g_strdup (self->set);
	new->set_line = self->set_line;
	new->line_no = self->line_no;
	return new;
}

static CCode *
copy_ccode (CCode * self)
{
	CCode * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == CCODE_NODE, NULL);
	new = g_new0(CCode, 1);
	new->type = CCODE_NODE;
	new->cctype = self->cctype;
	new->cbuf = g_strdup (self->cbuf);
	new->line_no = self->line_no;
	return new;
}

static Check *
copy_check (Check * self)
{
	Check * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == CHECK_NODE, NULL);
	new = g_new0(Check, 1);
	new->type = CHECK_NODE;
	new->chtype = self->chtype;
	new->number = g_strdup (self->number);
	return new;
}

static Class *
copy_class (Class * self)
{
	Class * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == CLASS_NODE, NULL);
	new = g_new0(Class, 1);
	new->type = CLASS_NODE;
	new->otype = g_strdup (self->otype);
	new->ptype = g_strdup (self->ptype);
	new->bonobo_object_class = g_strdup (self->bonobo_object_class);
	new->glade_xml = self->glade_xml;
	new->chunk_size = g_strdup (self->chunk_size);
	new->interfaces = g_list_copy (self->interfaces); COPY_LIST_VALS(new->interfaces, g_strdup);
	new->nodes = node_list_copy (self->nodes);
	new->abstract = self->abstract;
	return new;
}

static EnumDef *
copy_enumdef (EnumDef * self)
{
	EnumDef * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == ENUMDEF_NODE, NULL);
	new = g_new0(EnumDef, 1);
	new->type = ENUMDEF_NODE;
	new->etype = g_strdup (self->etype);
	new->prefix = g_strdup (self->prefix);
	new->values = node_list_copy (self->values);
	return new;
}

static EnumValue *
copy_enumvalue (EnumValue * self)
{
	EnumValue * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == ENUMVALUE_NODE, NULL);
	new = g_new0(EnumValue, 1);
	new->type = ENUMVALUE_NODE;
	new->name = g_strdup (self->name);
	new->value = g_strdup (self->value);
	return new;
}

static Error *
copy_error (Error * self)
{
	Error * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == ERROR_NODE, NULL);
	new = g_new0(Error, 1);
	new->type = ERROR_NODE;
	new->etype = g_strdup (self->etype);
	new->prefix = g_strdup (self->prefix);
	new->values = g_list_copy (self->values); COPY_LIST_VALS(new->values, g_strdup);
	return new;
}

static Flags *
copy_flags (Flags * self)
{
	Flags * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == FLAGS_NODE, NULL);
	new = g_new0(Flags, 1);
	new->type = FLAGS_NODE;
	new->ftype = g_strdup (self->ftype);
	new->prefix = g_strdup (self->prefix);
	new->values = g_list_copy (self->values); COPY_LIST_VALS(new->values, g_strdup);
	return new;
}

static FuncArg *
copy_funcarg (FuncArg * self)
{
	FuncArg * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == FUNCARG_NODE, NULL);
	new = g_new0(FuncArg, 1);
	new->type = FUNCARG_NODE;
	new->atype = copy_type (self->atype);
	new->name = g_strdup (self->name);
	new->checks = node_list_copy (self->checks);
	return new;
}

static Method *
copy_method (Method * self)
{
	Method * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == METHOD_NODE, NULL);
	new = g_new0(Method, 1);
	new->type = METHOD_NODE;
	new->scope = self->scope;
	new->method = self->method;
	new->mtype = copy_type (self->mtype);
	new->otype = g_strdup (self->otype);
	new->gtktypes = g_list_copy (self->gtktypes); COPY_LIST_VALS(new->gtktypes, g_strdup);
	new->flags = g_list_copy (self->flags); COPY_LIST_VALS(new->flags, g_strdup);
	new->id = g_strdup (self->id);
	new->args = node_list_copy (self->args);
	new->funcattrs = g_strdup (self->funcattrs);
	new->onerror = g_strdup (self->onerror);
	new->defreturn = g_strdup (self->defreturn);
	new->cbuf = g_strdup (self->cbuf);
	new->line_no = self->line_no;
	new->ccode_line = self->ccode_line;
	new->vararg = self->vararg;
	new->unique_id = self->unique_id;
	new->bonobo_object_func = self->bonobo_object_func;
	new->interface = g_strdup (self->interface);
	return new;
}

static Property *
copy_property (Property * self)
{
	Property * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == PROPERTY_NODE, NULL);
	new = g_new0(Property, 1);
	new->type = PROPERTY_NODE;
	new->gtktype = g_strdup (self->gtktype);
	new->ptype = copy_type (self->ptype);
	new->flags = g_list_copy (self->flags); COPY_LIST_VALS(new->flags, g_strdup);
	new->name = g_strdup (self->name);
	new->nick = g_strdup (self->nick);
	new->blurb = g_strdup (self->blurb);
	new->minimum = g_strdup (self->minimum);
	new->maximum = g_strdup (self->maximum);
	new->default_value = g_strdup (self->default_value);
	new->extra_gtktype = g_strdup (self->extra_gtktype);
	new->override = self->override;
	new->link = self->link;
	new->export = self->export;
	new->get = g_strdup (self->get);
	new->get_line = self->get_line;
	new->set = g_strdup (self->set);
	new->set_line = self->set_line;
	new->line_no = self->line_no;
	return new;
}

static Type *
copy_type (Type * self)
{
	Type * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == TYPE_NODE, NULL);
	new = g_new0(Type, 1);
	new->type = TYPE_NODE;
	new->name = g_strdup (self->name);
	new->pointer = g_strdup (self->pointer);
	new->postfix = g_strdup (self->postfix);
	return new;
}

static Variable *
copy_variable (Variable * self)
{
	Variable * new;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (self->type == VARIABLE_NODE, NULL);
	new = g_new0(Variable, 1);
	new->type = VARIABLE_NODE;
	new->scope = self->scope;
	new->vtype = copy_type (self->vtype);
	new->glade_widget = self->glade_widget;
	new->id = g_strdup (self->id);
	new->line_no = self->line_no;
	new->destructor_unref = self->destructor_unref;
	new->destructor = g_strdup (self->destructor);
	new->destructor_line = self->destructor_line;
	new->destructor_simple = self->destructor_simple;
	new->initializer = g_strdup (self->initializer);
	new->initializer_line = self->initializer_line;
	new->initializer_simple = self->initializer_simple;
	return new;
}

void
free_argument (Argument * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == ARGUMENT_NODE);
	g_free (self->gtktype);
	free_type (self->atype);
	g_list_foreach (self->flags, (GFunc)g_free, NULL); g_list_free (self->flags);
	g_free (self->name);
	g_free (self->get);
	g_free (self->set);
	g_free (self);
}

void
free_ccode (CCode * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == CCODE_NODE);
	g_free (self->cbuf);
	g_free (self);
}

void
free_check (Check * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == CHECK_NODE);
	g_free (self->number);
	g_free (self);
}

void
free_class (Class * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == CLASS_NODE);
	g_free (self->otype);
	g_free (self->ptype);
	g_free (self->bonobo_object_class);
	g_free (self->chunk_size);
	g_list_foreach (self->interfaces, (GFunc)g_free, NULL); g_list_free (self->interfaces);
	node_list_free (self->nodes);
	g_free (self);
}

void
free_enumdef (EnumDef * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == ENUMDEF_NODE);
	g_free (self->etype);
	g_free (self->prefix);
	node_list_free (self->values);
	g_free (self);
}

void
free_enumvalue (EnumValue * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == ENUMVALUE_NODE);
	g_free (self->name);
	g_free (self->value);
	g_free (self);
}

void
free_error (Error * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == ERROR_NODE);
	g_free (self->etype);
	g_free (self->prefix);
	g_list_foreach (self->values, (GFunc)g_free, NULL); g_list_free (self->values);
	g_free (self);
}

void
free_flags (Flags * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == FLAGS_NODE);
	g_free (self->ftype);
	g_free (self->prefix);
	g_list_foreach (self->values, (GFunc)g_free, NULL); g_list_free (self->values);
	g_free (self);
}

void
free_funcarg (FuncArg * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == FUNCARG_NODE);
	free_type (self->atype);
	g_free (self->name);
	node_list_free (self->checks);
	g_free (self);
}

void
free_method (Method * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == METHOD_NODE);
	free_type (self->mtype);
	g_free (self->otype);
	g_list_foreach (self->gtktypes, (GFunc)g_free, NULL); g_list_free (self->gtktypes);
	g_list_foreach (self->flags, (GFunc)g_free, NULL); g_list_free (self->flags);
	g_free (self->id);
	node_list_free (self->args);
	g_free (self->funcattrs);
	g_free (self->onerror);
	g_free (self->defreturn);
	g_free (self->cbuf);
	g_free (self->interface);
	g_free (self);
}

void
free_property (Property * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == PROPERTY_NODE);
	g_free (self->gtktype);
	free_type (self->ptype);
	g_list_foreach (self->flags, (GFunc)g_free, NULL); g_list_free (self->flags);
	g_free (self->name);
	g_free (self->nick);
	g_free (self->blurb);
	g_free (self->minimum);
	g_free (self->maximum);
	g_free (self->default_value);
	g_free (self->extra_gtktype);
	g_free (self->get);
	g_free (self->set);
	g_free (self);
}

void
free_type (Type * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == TYPE_NODE);
	g_free (self->name);
	g_free (self->pointer);
	g_free (self->postfix);
	g_free (self);
}

void
free_variable (Variable * self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (self->type == VARIABLE_NODE);
	free_type (self->vtype);
	g_free (self->id);
	g_free (self->destructor);
	g_free (self->initializer);
	g_free (self);
}

static void
setv_argument (Argument * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_gtktype: {
			char * gtktype = va_arg (__ap, char *);
			char * __old_value = self->gtktype;
			self->gtktype = g_strdup (gtktype);
			g_free (__old_value);
			break;
		}
		case QUARK_gtktype_STEAL: {
			char * gtktype = va_arg (__ap, char *);
			self->gtktype = gtktype;
			break;
		}
		case QUARK_atype: {
			Type * atype = va_arg (__ap, Type *);
			Type * __old_value = self->atype;
			self->atype = copy_type (atype);
			free_type (__old_value);
			break;
		}
		case QUARK_atype_STEAL: {
			Type * atype = va_arg (__ap, Type *);
			self->atype = atype;
			break;
		}
		case QUARK_flags: {
			GList * flags = va_arg (__ap, GList *);
			GList * __old_value = self->flags;
			self->flags = g_list_copy (flags); COPY_LIST_VALS(self->flags, g_strdup);
			g_list_foreach (__old_value, (GFunc)g_free, NULL); g_list_free (__old_value);
			break;
		}
		case QUARK_flags_STEAL: {
			GList * flags = va_arg (__ap, GList *);
			self->flags = flags;
			break;
		}
		case QUARK_name: {
			char * name = va_arg (__ap, char *);
			char * __old_value = self->name;
			self->name = g_strdup (name);
			g_free (__old_value);
			break;
		}
		case QUARK_name_STEAL: {
			char * name = va_arg (__ap, char *);
			self->name = name;
			break;
		}
		case QUARK_get: {
			char * get = va_arg (__ap, char *);
			char * __old_value = self->get;
			self->get = g_strdup (get);
			g_free (__old_value);
			break;
		}
		case QUARK_get_STEAL: {
			char * get = va_arg (__ap, char *);
			self->get = get;
			break;
		}
		case QUARK_get_line: {
			int get_line = va_arg (__ap, int);
			self->get_line = get_line;
			break;
		}
		case QUARK_set: {
			char * set = va_arg (__ap, char *);
			char * __old_value = self->set;
			self->set = g_strdup (set);
			g_free (__old_value);
			break;
		}
		case QUARK_set_STEAL: {
			char * set = va_arg (__ap, char *);
			self->set = set;
			break;
		}
		case QUARK_set_line: {
			int set_line = va_arg (__ap, int);
			self->set_line = set_line;
			break;
		}
		case QUARK_line_no: {
			int line_no = va_arg (__ap, int);
			self->line_no = line_no;
			break;
		}
		default:
			g_warning ("Argument named 'Argument::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_ccode (CCode * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_cctype: {
			int cctype = va_arg (__ap, int);
			self->cctype = cctype;
			break;
		}
		case QUARK_cbuf: {
			char * cbuf = va_arg (__ap, char *);
			char * __old_value = self->cbuf;
			self->cbuf = g_strdup (cbuf);
			g_free (__old_value);
			break;
		}
		case QUARK_cbuf_STEAL: {
			char * cbuf = va_arg (__ap, char *);
			self->cbuf = cbuf;
			break;
		}
		case QUARK_line_no: {
			int line_no = va_arg (__ap, int);
			self->line_no = line_no;
			break;
		}
		default:
			g_warning ("Argument named 'CCode::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_check (Check * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_chtype: {
			int chtype = va_arg (__ap, int);
			self->chtype = chtype;
			break;
		}
		case QUARK_number: {
			char * number = va_arg (__ap, char *);
			char * __old_value = self->number;
			self->number = g_strdup (number);
			g_free (__old_value);
			break;
		}
		case QUARK_number_STEAL: {
			char * number = va_arg (__ap, char *);
			self->number = number;
			break;
		}
		default:
			g_warning ("Argument named 'Check::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_class (Class * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_otype: {
			char * otype = va_arg (__ap, char *);
			char * __old_value = self->otype;
			self->otype = g_strdup (otype);
			g_free (__old_value);
			break;
		}
		case QUARK_otype_STEAL: {
			char * otype = va_arg (__ap, char *);
			self->otype = otype;
			break;
		}
		case QUARK_ptype: {
			char * ptype = va_arg (__ap, char *);
			char * __old_value = self->ptype;
			self->ptype = g_strdup (ptype);
			g_free (__old_value);
			break;
		}
		case QUARK_ptype_STEAL: {
			char * ptype = va_arg (__ap, char *);
			self->ptype = ptype;
			break;
		}
		case QUARK_bonobo_object_class: {
			char * bonobo_object_class = va_arg (__ap, char *);
			char * __old_value = self->bonobo_object_class;
			self->bonobo_object_class = g_strdup (bonobo_object_class);
			g_free (__old_value);
			break;
		}
		case QUARK_bonobo_object_class_STEAL: {
			char * bonobo_object_class = va_arg (__ap, char *);
			self->bonobo_object_class = bonobo_object_class;
			break;
		}
		case QUARK_glade_xml: {
			gboolean glade_xml = va_arg (__ap, gboolean);
			self->glade_xml = glade_xml;
			break;
		}
		case QUARK_chunk_size: {
			char * chunk_size = va_arg (__ap, char *);
			char * __old_value = self->chunk_size;
			self->chunk_size = g_strdup (chunk_size);
			g_free (__old_value);
			break;
		}
		case QUARK_chunk_size_STEAL: {
			char * chunk_size = va_arg (__ap, char *);
			self->chunk_size = chunk_size;
			break;
		}
		case QUARK_interfaces: {
			GList * interfaces = va_arg (__ap, GList *);
			GList * __old_value = self->interfaces;
			self->interfaces = g_list_copy (interfaces); COPY_LIST_VALS(self->interfaces, g_strdup);
			g_list_foreach (__old_value, (GFunc)g_free, NULL); g_list_free (__old_value);
			break;
		}
		case QUARK_interfaces_STEAL: {
			GList * interfaces = va_arg (__ap, GList *);
			self->interfaces = interfaces;
			break;
		}
		case QUARK_nodes: {
			GList * nodes = va_arg (__ap, GList *);
			GList * __old_value = self->nodes;
			self->nodes = node_list_copy (nodes);
			node_list_free (__old_value);
			break;
		}
		case QUARK_nodes_STEAL: {
			GList * nodes = va_arg (__ap, GList *);
			self->nodes = nodes;
			break;
		}
		case QUARK_abstract: {
			gboolean abstract = va_arg (__ap, gboolean);
			self->abstract = abstract;
			break;
		}
		default:
			g_warning ("Argument named 'Class::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_enumdef (EnumDef * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_etype: {
			char * etype = va_arg (__ap, char *);
			char * __old_value = self->etype;
			self->etype = g_strdup (etype);
			g_free (__old_value);
			break;
		}
		case QUARK_etype_STEAL: {
			char * etype = va_arg (__ap, char *);
			self->etype = etype;
			break;
		}
		case QUARK_prefix: {
			char * prefix = va_arg (__ap, char *);
			char * __old_value = self->prefix;
			self->prefix = g_strdup (prefix);
			g_free (__old_value);
			break;
		}
		case QUARK_prefix_STEAL: {
			char * prefix = va_arg (__ap, char *);
			self->prefix = prefix;
			break;
		}
		case QUARK_values: {
			GList * values = va_arg (__ap, GList *);
			GList * __old_value = self->values;
			self->values = node_list_copy (values);
			node_list_free (__old_value);
			break;
		}
		case QUARK_values_STEAL: {
			GList * values = va_arg (__ap, GList *);
			self->values = values;
			break;
		}
		default:
			g_warning ("Argument named 'EnumDef::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_enumvalue (EnumValue * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_name: {
			char * name = va_arg (__ap, char *);
			char * __old_value = self->name;
			self->name = g_strdup (name);
			g_free (__old_value);
			break;
		}
		case QUARK_name_STEAL: {
			char * name = va_arg (__ap, char *);
			self->name = name;
			break;
		}
		case QUARK_value: {
			char * value = va_arg (__ap, char *);
			char * __old_value = self->value;
			self->value = g_strdup (value);
			g_free (__old_value);
			break;
		}
		case QUARK_value_STEAL: {
			char * value = va_arg (__ap, char *);
			self->value = value;
			break;
		}
		default:
			g_warning ("Argument named 'EnumValue::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_error (Error * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_etype: {
			char * etype = va_arg (__ap, char *);
			char * __old_value = self->etype;
			self->etype = g_strdup (etype);
			g_free (__old_value);
			break;
		}
		case QUARK_etype_STEAL: {
			char * etype = va_arg (__ap, char *);
			self->etype = etype;
			break;
		}
		case QUARK_prefix: {
			char * prefix = va_arg (__ap, char *);
			char * __old_value = self->prefix;
			self->prefix = g_strdup (prefix);
			g_free (__old_value);
			break;
		}
		case QUARK_prefix_STEAL: {
			char * prefix = va_arg (__ap, char *);
			self->prefix = prefix;
			break;
		}
		case QUARK_values: {
			GList * values = va_arg (__ap, GList *);
			GList * __old_value = self->values;
			self->values = g_list_copy (values); COPY_LIST_VALS(self->values, g_strdup);
			g_list_foreach (__old_value, (GFunc)g_free, NULL); g_list_free (__old_value);
			break;
		}
		case QUARK_values_STEAL: {
			GList * values = va_arg (__ap, GList *);
			self->values = values;
			break;
		}
		default:
			g_warning ("Argument named 'Error::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_flags (Flags * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_ftype: {
			char * ftype = va_arg (__ap, char *);
			char * __old_value = self->ftype;
			self->ftype = g_strdup (ftype);
			g_free (__old_value);
			break;
		}
		case QUARK_ftype_STEAL: {
			char * ftype = va_arg (__ap, char *);
			self->ftype = ftype;
			break;
		}
		case QUARK_prefix: {
			char * prefix = va_arg (__ap, char *);
			char * __old_value = self->prefix;
			self->prefix = g_strdup (prefix);
			g_free (__old_value);
			break;
		}
		case QUARK_prefix_STEAL: {
			char * prefix = va_arg (__ap, char *);
			self->prefix = prefix;
			break;
		}
		case QUARK_values: {
			GList * values = va_arg (__ap, GList *);
			GList * __old_value = self->values;
			self->values = g_list_copy (values); COPY_LIST_VALS(self->values, g_strdup);
			g_list_foreach (__old_value, (GFunc)g_free, NULL); g_list_free (__old_value);
			break;
		}
		case QUARK_values_STEAL: {
			GList * values = va_arg (__ap, GList *);
			self->values = values;
			break;
		}
		default:
			g_warning ("Argument named 'Flags::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_funcarg (FuncArg * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_atype: {
			Type * atype = va_arg (__ap, Type *);
			Type * __old_value = self->atype;
			self->atype = copy_type (atype);
			free_type (__old_value);
			break;
		}
		case QUARK_atype_STEAL: {
			Type * atype = va_arg (__ap, Type *);
			self->atype = atype;
			break;
		}
		case QUARK_name: {
			char * name = va_arg (__ap, char *);
			char * __old_value = self->name;
			self->name = g_strdup (name);
			g_free (__old_value);
			break;
		}
		case QUARK_name_STEAL: {
			char * name = va_arg (__ap, char *);
			self->name = name;
			break;
		}
		case QUARK_checks: {
			GList * checks = va_arg (__ap, GList *);
			GList * __old_value = self->checks;
			self->checks = node_list_copy (checks);
			node_list_free (__old_value);
			break;
		}
		case QUARK_checks_STEAL: {
			GList * checks = va_arg (__ap, GList *);
			self->checks = checks;
			break;
		}
		default:
			g_warning ("Argument named 'FuncArg::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_method (Method * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_scope: {
			int scope = va_arg (__ap, int);
			self->scope = scope;
			break;
		}
		case QUARK_method: {
			int method = va_arg (__ap, int);
			self->method = method;
			break;
		}
		case QUARK_mtype: {
			Type * mtype = va_arg (__ap, Type *);
			Type * __old_value = self->mtype;
			self->mtype = copy_type (mtype);
			free_type (__old_value);
			break;
		}
		case QUARK_mtype_STEAL: {
			Type * mtype = va_arg (__ap, Type *);
			self->mtype = mtype;
			break;
		}
		case QUARK_otype: {
			char * otype = va_arg (__ap, char *);
			char * __old_value = self->otype;
			self->otype = g_strdup (otype);
			g_free (__old_value);
			break;
		}
		case QUARK_otype_STEAL: {
			char * otype = va_arg (__ap, char *);
			self->otype = otype;
			break;
		}
		case QUARK_gtktypes: {
			GList * gtktypes = va_arg (__ap, GList *);
			GList * __old_value = self->gtktypes;
			self->gtktypes = g_list_copy (gtktypes); COPY_LIST_VALS(self->gtktypes, g_strdup);
			g_list_foreach (__old_value, (GFunc)g_free, NULL); g_list_free (__old_value);
			break;
		}
		case QUARK_gtktypes_STEAL: {
			GList * gtktypes = va_arg (__ap, GList *);
			self->gtktypes = gtktypes;
			break;
		}
		case QUARK_flags: {
			GList * flags = va_arg (__ap, GList *);
			GList * __old_value = self->flags;
			self->flags = g_list_copy (flags); COPY_LIST_VALS(self->flags, g_strdup);
			g_list_foreach (__old_value, (GFunc)g_free, NULL); g_list_free (__old_value);
			break;
		}
		case QUARK_flags_STEAL: {
			GList * flags = va_arg (__ap, GList *);
			self->flags = flags;
			break;
		}
		case QUARK_id: {
			char * id = va_arg (__ap, char *);
			char * __old_value = self->id;
			self->id = g_strdup (id);
			g_free (__old_value);
			break;
		}
		case QUARK_id_STEAL: {
			char * id = va_arg (__ap, char *);
			self->id = id;
			break;
		}
		case QUARK_args: {
			GList * args = va_arg (__ap, GList *);
			GList * __old_value = self->args;
			self->args = node_list_copy (args);
			node_list_free (__old_value);
			break;
		}
		case QUARK_args_STEAL: {
			GList * args = va_arg (__ap, GList *);
			self->args = args;
			break;
		}
		case QUARK_funcattrs: {
			char * funcattrs = va_arg (__ap, char *);
			char * __old_value = self->funcattrs;
			self->funcattrs = g_strdup (funcattrs);
			g_free (__old_value);
			break;
		}
		case QUARK_funcattrs_STEAL: {
			char * funcattrs = va_arg (__ap, char *);
			self->funcattrs = funcattrs;
			break;
		}
		case QUARK_onerror: {
			char * onerror = va_arg (__ap, char *);
			char * __old_value = self->onerror;
			self->onerror = g_strdup (onerror);
			g_free (__old_value);
			break;
		}
		case QUARK_onerror_STEAL: {
			char * onerror = va_arg (__ap, char *);
			self->onerror = onerror;
			break;
		}
		case QUARK_defreturn: {
			char * defreturn = va_arg (__ap, char *);
			char * __old_value = self->defreturn;
			self->defreturn = g_strdup (defreturn);
			g_free (__old_value);
			break;
		}
		case QUARK_defreturn_STEAL: {
			char * defreturn = va_arg (__ap, char *);
			self->defreturn = defreturn;
			break;
		}
		case QUARK_cbuf: {
			char * cbuf = va_arg (__ap, char *);
			char * __old_value = self->cbuf;
			self->cbuf = g_strdup (cbuf);
			g_free (__old_value);
			break;
		}
		case QUARK_cbuf_STEAL: {
			char * cbuf = va_arg (__ap, char *);
			self->cbuf = cbuf;
			break;
		}
		case QUARK_line_no: {
			int line_no = va_arg (__ap, int);
			self->line_no = line_no;
			break;
		}
		case QUARK_ccode_line: {
			int ccode_line = va_arg (__ap, int);
			self->ccode_line = ccode_line;
			break;
		}
		case QUARK_vararg: {
			gboolean vararg = va_arg (__ap, gboolean);
			self->vararg = vararg;
			break;
		}
		case QUARK_unique_id: {
			int unique_id = va_arg (__ap, int);
			self->unique_id = unique_id;
			break;
		}
		case QUARK_bonobo_object_func: {
			gboolean bonobo_object_func = va_arg (__ap, gboolean);
			self->bonobo_object_func = bonobo_object_func;
			break;
		}
		case QUARK_interface: {
			char * interface = va_arg (__ap, char *);
			char * __old_value = self->interface;
			self->interface = g_strdup (interface);
			g_free (__old_value);
			break;
		}
		case QUARK_interface_STEAL: {
			char * interface = va_arg (__ap, char *);
			self->interface = interface;
			break;
		}
		default:
			g_warning ("Argument named 'Method::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_property (Property * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_gtktype: {
			char * gtktype = va_arg (__ap, char *);
			char * __old_value = self->gtktype;
			self->gtktype = g_strdup (gtktype);
			g_free (__old_value);
			break;
		}
		case QUARK_gtktype_STEAL: {
			char * gtktype = va_arg (__ap, char *);
			self->gtktype = gtktype;
			break;
		}
		case QUARK_ptype: {
			Type * ptype = va_arg (__ap, Type *);
			Type * __old_value = self->ptype;
			self->ptype = copy_type (ptype);
			free_type (__old_value);
			break;
		}
		case QUARK_ptype_STEAL: {
			Type * ptype = va_arg (__ap, Type *);
			self->ptype = ptype;
			break;
		}
		case QUARK_flags: {
			GList * flags = va_arg (__ap, GList *);
			GList * __old_value = self->flags;
			self->flags = g_list_copy (flags); COPY_LIST_VALS(self->flags, g_strdup);
			g_list_foreach (__old_value, (GFunc)g_free, NULL); g_list_free (__old_value);
			break;
		}
		case QUARK_flags_STEAL: {
			GList * flags = va_arg (__ap, GList *);
			self->flags = flags;
			break;
		}
		case QUARK_name: {
			char * name = va_arg (__ap, char *);
			char * __old_value = self->name;
			self->name = g_strdup (name);
			g_free (__old_value);
			break;
		}
		case QUARK_name_STEAL: {
			char * name = va_arg (__ap, char *);
			self->name = name;
			break;
		}
		case QUARK_nick: {
			char * nick = va_arg (__ap, char *);
			char * __old_value = self->nick;
			self->nick = g_strdup (nick);
			g_free (__old_value);
			break;
		}
		case QUARK_nick_STEAL: {
			char * nick = va_arg (__ap, char *);
			self->nick = nick;
			break;
		}
		case QUARK_blurb: {
			char * blurb = va_arg (__ap, char *);
			char * __old_value = self->blurb;
			self->blurb = g_strdup (blurb);
			g_free (__old_value);
			break;
		}
		case QUARK_blurb_STEAL: {
			char * blurb = va_arg (__ap, char *);
			self->blurb = blurb;
			break;
		}
		case QUARK_minimum: {
			char * minimum = va_arg (__ap, char *);
			char * __old_value = self->minimum;
			self->minimum = g_strdup (minimum);
			g_free (__old_value);
			break;
		}
		case QUARK_minimum_STEAL: {
			char * minimum = va_arg (__ap, char *);
			self->minimum = minimum;
			break;
		}
		case QUARK_maximum: {
			char * maximum = va_arg (__ap, char *);
			char * __old_value = self->maximum;
			self->maximum = g_strdup (maximum);
			g_free (__old_value);
			break;
		}
		case QUARK_maximum_STEAL: {
			char * maximum = va_arg (__ap, char *);
			self->maximum = maximum;
			break;
		}
		case QUARK_default_value: {
			char * default_value = va_arg (__ap, char *);
			char * __old_value = self->default_value;
			self->default_value = g_strdup (default_value);
			g_free (__old_value);
			break;
		}
		case QUARK_default_value_STEAL: {
			char * default_value = va_arg (__ap, char *);
			self->default_value = default_value;
			break;
		}
		case QUARK_extra_gtktype: {
			char * extra_gtktype = va_arg (__ap, char *);
			char * __old_value = self->extra_gtktype;
			self->extra_gtktype = g_strdup (extra_gtktype);
			g_free (__old_value);
			break;
		}
		case QUARK_extra_gtktype_STEAL: {
			char * extra_gtktype = va_arg (__ap, char *);
			self->extra_gtktype = extra_gtktype;
			break;
		}
		case QUARK_override: {
			gboolean override = va_arg (__ap, gboolean);
			self->override = override;
			break;
		}
		case QUARK_link: {
			gboolean link = va_arg (__ap, gboolean);
			self->link = link;
			break;
		}
		case QUARK_export: {
			gboolean export = va_arg (__ap, gboolean);
			self->export = export;
			break;
		}
		case QUARK_get: {
			char * get = va_arg (__ap, char *);
			char * __old_value = self->get;
			self->get = g_strdup (get);
			g_free (__old_value);
			break;
		}
		case QUARK_get_STEAL: {
			char * get = va_arg (__ap, char *);
			self->get = get;
			break;
		}
		case QUARK_get_line: {
			int get_line = va_arg (__ap, int);
			self->get_line = get_line;
			break;
		}
		case QUARK_set: {
			char * set = va_arg (__ap, char *);
			char * __old_value = self->set;
			self->set = g_strdup (set);
			g_free (__old_value);
			break;
		}
		case QUARK_set_STEAL: {
			char * set = va_arg (__ap, char *);
			self->set = set;
			break;
		}
		case QUARK_set_line: {
			int set_line = va_arg (__ap, int);
			self->set_line = set_line;
			break;
		}
		case QUARK_line_no: {
			int line_no = va_arg (__ap, int);
			self->line_no = line_no;
			break;
		}
		default:
			g_warning ("Argument named 'Property::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_type (Type * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_name: {
			char * name = va_arg (__ap, char *);
			char * __old_value = self->name;
			self->name = g_strdup (name);
			g_free (__old_value);
			break;
		}
		case QUARK_name_STEAL: {
			char * name = va_arg (__ap, char *);
			self->name = name;
			break;
		}
		case QUARK_pointer: {
			char * pointer = va_arg (__ap, char *);
			char * __old_value = self->pointer;
			self->pointer = g_strdup (pointer);
			g_free (__old_value);
			break;
		}
		case QUARK_pointer_STEAL: {
			char * pointer = va_arg (__ap, char *);
			self->pointer = pointer;
			break;
		}
		case QUARK_postfix: {
			char * postfix = va_arg (__ap, char *);
			char * __old_value = self->postfix;
			self->postfix = g_strdup (postfix);
			g_free (__old_value);
			break;
		}
		case QUARK_postfix_STEAL: {
			char * postfix = va_arg (__ap, char *);
			self->postfix = postfix;
			break;
		}
		default:
			g_warning ("Argument named 'Type::%s' does not exist", arg);
			break;
		}
	}
}

static void
setv_variable (Variable * self, va_list __ap)
{
	int quark;
	const char *arg;
	ensure_quarks ();
	while ((arg = va_arg (__ap, char *)) != NULL) {
		quark = GPOINTER_TO_INT (g_hash_table_lookup (quark_ht, arg));
		switch (quark) {
		case QUARK_scope: {
			int scope = va_arg (__ap, int);
			self->scope = scope;
			break;
		}
		case QUARK_vtype: {
			Type * vtype = va_arg (__ap, Type *);
			Type * __old_value = self->vtype;
			self->vtype = copy_type (vtype);
			free_type (__old_value);
			break;
		}
		case QUARK_vtype_STEAL: {
			Type * vtype = va_arg (__ap, Type *);
			self->vtype = vtype;
			break;
		}
		case QUARK_glade_widget: {
			gboolean glade_widget = va_arg (__ap, gboolean);
			self->glade_widget = glade_widget;
			break;
		}
		case QUARK_id: {
			char * id = va_arg (__ap, char *);
			char * __old_value = self->id;
			self->id = g_strdup (id);
			g_free (__old_value);
			break;
		}
		case QUARK_id_STEAL: {
			char * id = va_arg (__ap, char *);
			self->id = id;
			break;
		}
		case QUARK_line_no: {
			int line_no = va_arg (__ap, int);
			self->line_no = line_no;
			break;
		}
		case QUARK_destructor_unref: {
			gboolean destructor_unref = va_arg (__ap, gboolean);
			self->destructor_unref = destructor_unref;
			break;
		}
		case QUARK_destructor: {
			char * destructor = va_arg (__ap, char *);
			char * __old_value = self->destructor;
			self->destructor = g_strdup (destructor);
			g_free (__old_value);
			break;
		}
		case QUARK_destructor_STEAL: {
			char * destructor = va_arg (__ap, char *);
			self->destructor = destructor;
			break;
		}
		case QUARK_destructor_line: {
			int destructor_line = va_arg (__ap, int);
			self->destructor_line = destructor_line;
			break;
		}
		case QUARK_destructor_simple: {
			gboolean destructor_simple = va_arg (__ap, gboolean);
			self->destructor_simple = destructor_simple;
			break;
		}
		case QUARK_initializer: {
			char * initializer = va_arg (__ap, char *);
			char * __old_value = self->initializer;
			self->initializer = g_strdup (initializer);
			g_free (__old_value);
			break;
		}
		case QUARK_initializer_STEAL: {
			char * initializer = va_arg (__ap, char *);
			self->initializer = initializer;
			break;
		}
		case QUARK_initializer_line: {
			int initializer_line = va_arg (__ap, int);
			self->initializer_line = initializer_line;
			break;
		}
		case QUARK_initializer_simple: {
			gboolean initializer_simple = va_arg (__ap, gboolean);
			self->initializer_simple = initializer_simple;
			break;
		}
		default:
			g_warning ("Argument named 'Variable::%s' does not exist", arg);
			break;
		}
	}
}

Node *
node_copy (Node *node)
{
	g_return_val_if_fail (node != NULL, NULL);
	g_return_val_if_fail (node->type >= 0 && node->type < LAST_NODE_TYPE, NULL);
	switch (node->type) {
	case ARGUMENT_NODE: return (Node *)copy_argument ((Argument *)node);
	case CCODE_NODE: return (Node *)copy_ccode ((CCode *)node);
	case CHECK_NODE: return (Node *)copy_check ((Check *)node);
	case CLASS_NODE: return (Node *)copy_class ((Class *)node);
	case ENUMDEF_NODE: return (Node *)copy_enumdef ((EnumDef *)node);
	case ENUMVALUE_NODE: return (Node *)copy_enumvalue ((EnumValue *)node);
	case ERROR_NODE: return (Node *)copy_error ((Error *)node);
	case FLAGS_NODE: return (Node *)copy_flags ((Flags *)node);
	case FUNCARG_NODE: return (Node *)copy_funcarg ((FuncArg *)node);
	case METHOD_NODE: return (Node *)copy_method ((Method *)node);
	case PROPERTY_NODE: return (Node *)copy_property ((Property *)node);
	case TYPE_NODE: return (Node *)copy_type ((Type *)node);
	case VARIABLE_NODE: return (Node *)copy_variable ((Variable *)node);
	default: return NULL;
	}
}

static void
node_setv (Node *node, va_list __ap)
{
	g_return_if_fail (node != NULL);
	g_return_if_fail (node->type >= 0 && node->type < LAST_NODE_TYPE);
	switch (node->type) {
	case ARGUMENT_NODE: setv_argument ((Argument *)node, __ap); break;
	case CCODE_NODE: setv_ccode ((CCode *)node, __ap); break;
	case CHECK_NODE: setv_check ((Check *)node, __ap); break;
	case CLASS_NODE: setv_class ((Class *)node, __ap); break;
	case ENUMDEF_NODE: setv_enumdef ((EnumDef *)node, __ap); break;
	case ENUMVALUE_NODE: setv_enumvalue ((EnumValue *)node, __ap); break;
	case ERROR_NODE: setv_error ((Error *)node, __ap); break;
	case FLAGS_NODE: setv_flags ((Flags *)node, __ap); break;
	case FUNCARG_NODE: setv_funcarg ((FuncArg *)node, __ap); break;
	case METHOD_NODE: setv_method ((Method *)node, __ap); break;
	case PROPERTY_NODE: setv_property ((Property *)node, __ap); break;
	case TYPE_NODE: setv_type ((Type *)node, __ap); break;
	case VARIABLE_NODE: setv_variable ((Variable *)node, __ap); break;
	default: break;
	}
}

void
node_set (Node *node, ...)
{
	va_list __ap;
	va_start (__ap, node);
	node_setv (node, __ap);
	va_end (__ap);
}

Node *
node_new (NodeType type, ...)
{
	va_list __ap;
	Node *node = NULL;
	va_start (__ap, type);
	g_return_val_if_fail (type >= 0 && type < LAST_NODE_TYPE, NULL);
	switch (type) {
	case ARGUMENT_NODE:
		node = (Node *)g_new0 (Argument, 1);
		node->type = type;
		setv_argument ((Argument *)node, __ap);
		break;
	case CCODE_NODE:
		node = (Node *)g_new0 (CCode, 1);
		node->type = type;
		setv_ccode ((CCode *)node, __ap);
		break;
	case CHECK_NODE:
		node = (Node *)g_new0 (Check, 1);
		node->type = type;
		setv_check ((Check *)node, __ap);
		break;
	case CLASS_NODE:
		node = (Node *)g_new0 (Class, 1);
		node->type = type;
		setv_class ((Class *)node, __ap);
		break;
	case ENUMDEF_NODE:
		node = (Node *)g_new0 (EnumDef, 1);
		node->type = type;
		setv_enumdef ((EnumDef *)node, __ap);
		break;
	case ENUMVALUE_NODE:
		node = (Node *)g_new0 (EnumValue, 1);
		node->type = type;
		setv_enumvalue ((EnumValue *)node, __ap);
		break;
	case ERROR_NODE:
		node = (Node *)g_new0 (Error, 1);
		node->type = type;
		setv_error ((Error *)node, __ap);
		break;
	case FLAGS_NODE:
		node = (Node *)g_new0 (Flags, 1);
		node->type = type;
		setv_flags ((Flags *)node, __ap);
		break;
	case FUNCARG_NODE:
		node = (Node *)g_new0 (FuncArg, 1);
		node->type = type;
		setv_funcarg ((FuncArg *)node, __ap);
		break;
	case METHOD_NODE:
		node = (Node *)g_new0 (Method, 1);
		node->type = type;
		setv_method ((Method *)node, __ap);
		break;
	case PROPERTY_NODE:
		node = (Node *)g_new0 (Property, 1);
		node->type = type;
		setv_property ((Property *)node, __ap);
		break;
	case TYPE_NODE:
		node = (Node *)g_new0 (Type, 1);
		node->type = type;
		setv_type ((Type *)node, __ap);
		break;
	case VARIABLE_NODE:
		node = (Node *)g_new0 (Variable, 1);
		node->type = type;
		setv_variable ((Variable *)node, __ap);
		break;
	default: break;
	}
	va_end (__ap);
	return node;
}

void
node_free (Node *node)
{
	g_return_if_fail (node != NULL);
	g_return_if_fail (node->type >= 0 && node->type < LAST_NODE_TYPE);
	switch (node->type) {
	case ARGUMENT_NODE: free_argument ((Argument *)node); return;
	case CCODE_NODE: free_ccode ((CCode *)node); return;
	case CHECK_NODE: free_check ((Check *)node); return;
	case CLASS_NODE: free_class ((Class *)node); return;
	case ENUMDEF_NODE: free_enumdef ((EnumDef *)node); return;
	case ENUMVALUE_NODE: free_enumvalue ((EnumValue *)node); return;
	case ERROR_NODE: free_error ((Error *)node); return;
	case FLAGS_NODE: free_flags ((Flags *)node); return;
	case FUNCARG_NODE: free_funcarg ((FuncArg *)node); return;
	case METHOD_NODE: free_method ((Method *)node); return;
	case PROPERTY_NODE: free_property ((Property *)node); return;
	case TYPE_NODE: free_type ((Type *)node); return;
	case VARIABLE_NODE: free_variable ((Variable *)node); return;
	default: return;
	}
}

GList *
node_list_copy (GList *nodes)
{
	GList *li;
	nodes = g_list_copy (nodes);
	for (li = nodes; li != NULL; li = li->next) {
		li->data = node_copy (li->data);
	}
	return nodes;
}

void
node_list_free (GList *nodes)
{
	GList *li;
	for (li = nodes; li != NULL; li = li->next) {
		node_free (li->data);
	}
	g_list_free (nodes);
}

